<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluation Management & Allocation</title>
    <link rel="stylesheet" href="../../css/main.css">
    <style>
        .evaluation-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .section-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }

        .section-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
        }

        .tab-button {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-button.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Evaluation Management Styles */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .panel-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-body {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .request-item, .evaluator-item {
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #f8f9fa;
        }

        .request-header, .evaluator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background: #e9ecef;
        }

        .profile-pic-placeholder {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .request-name, .evaluator-name {
            font-weight: 600;
            color: #333;
        }

        .request-date, .evaluator-status {
            font-size: 0.9em;
            color: #666;
        }

        .subjects-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .subject-tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn:hover {
            opacity: 0.8;
            transform: translateY(-2px);
        }

        .evaluator-status.enabled {
            color: #28a745;
        }

        .evaluator-status.disabled {
            color: #dc3545;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-weight: 500;
            color: #555;
        }

        .filter-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        /* Add Evaluator Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .tutor-selection-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .tutor-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tutor-item:hover {
            background-color: #f8f9fa;
        }

        .tutor-item.selected {
            background-color: #e3f2fd;
        }

        /* Evaluation Allocation Styles */
        .allocation-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .exam-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .exam-selector select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-width: 200px;
        }

        .allocation-grid {
            display: grid;
            gap: 20px;
        }

        .subject-allocation {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }

        .subject-header {
            background: #667eea;
            color: white;
            padding: 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .allocation-content {
            padding: 15px;
        }

        .evaluator-allocation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            margin-bottom: 10px;
            background: #f9f9f9;
        }

        .allocation-info {
            flex-grow: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .allocation-actions {
            display: flex;
            gap: 5px;
        }

        .answer-sets-count {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .unassigned-papers {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
        }

        .paper-assignment {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            z-index: 1000;
            display: none;
        }

        .notification.success {
            background: #28a745;
        }

        .notification.error {
            background: #dc3545;
        }

        .notification.warning {
            background: #ffc107;
            color: #212529;
        }

        .badge {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: normal;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .control-buttons, .filter-controls {
                flex-direction: column;
            }

            .exam-selector {
                flex-direction: column;
                align-items: stretch;
            }
        }

        .evaluator-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .evaluator-card:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }

        .evaluator-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .evaluator-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #e3f2fd;
        }

        .evaluator-avatar-placeholder {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            border: 3px solid #e3f2fd;
        }

        .evaluator-details h4 {
            margin: 0 0 0.25rem 0;
            color: #333;
            font-size: 1.1rem;
        }

        .evaluator-details p {
            margin: 0;
            font-size: 0.9rem;
        }

        .evaluator-body {
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .evaluator-body p {
            margin: 0.5rem 0;
        }

        .evaluator-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            border-top: 1px solid #eee;
            padding-top: 1rem;
        }

        .pending-request {
            border-left: 4px solid #ffc107;
        }

        .active-evaluator {
            border-left: 4px solid #28a745;
        }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-badge.pending {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-badge.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .section-actions {
            margin-top: 1rem;
            text-align: center;
        }

        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 0;
            border: none;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
        }

        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            opacity: 0.7;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        #subjectsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
        }

        .subject-checkbox {
            display: flex;
            align-items: center;
        }

        .subject-checkbox label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-color);
        }

        .subject-checkbox input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e1e5e9;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .allocation-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
        }

        .placeholder-content h3 {
            color: #333;
            margin-bottom: 1rem;
        }

        .placeholder-features {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .feature-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 120px;
        }

        .feature-icon {
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <div class="evaluation-container">
        <!-- Header -->
        <div class="section-header">
            <h1>üìä Evaluation Management & Allocation System</h1>
            <p>Manage evaluator eligibility and allocate answer sets for evaluation</p>
        </div>

        <!-- Section Tabs -->
        <div class="section-tabs">
            <button class="tab-button active" onclick="switchTab('management')">
                üìã Evaluation Management
            </button>
            <button class="tab-button" onclick="switchTab('allocation')">
                üéØ Evaluation Allocation
            </button>
        </div>

        <!-- EVALUATION MANAGEMENT TAB -->
        <div id="managementTab" class="tab-content active">
            <!-- Statistics -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalRequestsCount">0</div>
                    <div>Pending Requests</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalEvaluatorsCount">0</div>
                    <div>Active Evaluators</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalSubjectsCount">0</div>
                    <div>Covered Subjects</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="averageSubjectsCount">0</div>
                    <div>Avg. Subjects/Evaluator</div>
                </div>
            </div>

            <!-- Control Buttons -->
            <div class="control-buttons">
                <button class="btn btn-primary" onclick="openAddEvaluatorModal()">
                    ‚ûï Add Evaluator
                </button>
                <button class="btn btn-success" onclick="approveAllPendingRequests()">
                    ‚úÖ Approve All Pending
                </button>
                <button class="btn btn-warning" onclick="disableAllEvaluators()">
                    ‚è∏Ô∏è Disable All Evaluators
                </button>
                <button class="btn btn-secondary" onclick="exportEvaluationData()">
                    üìä Export Data
                </button>
                <button class="btn btn-secondary" onclick="loadEvaluationManagement()">
                    üîÑ Refresh Data
                </button>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="subjectFilter">Filter by Subject:</label>
                    <select id="subjectFilter" onchange="filterEvaluators()">
                        <option value="">All Subjects</option>
                        <option value="Mathematics">Mathematics</option>
                        <option value="Physics">Physics</option>
                        <option value="Chemistry">Chemistry</option>
                        <option value="Biology">Biology</option>
                        <option value="English">English</option>
                        <option value="Bangla">Bangla</option>
                        <option value="General Knowledge">General Knowledge</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="statusFilter">Filter by Status:</label>
                    <select id="statusFilter" onchange="filterEvaluators()">
                        <option value="">All Status</option>
                        <option value="true">Enabled</option>
                        <option value="false">Disabled</option>
                    </select>
                </div>
            </div>

            <!-- Content Grid -->
            <div class="content-grid">
                <!-- Pending Requests Panel -->
                <div class="panel">
                    <div class="panel-header">
                        üì• Pending Evaluator Requests
                        <span class="badge" id="pendingRequestsBadge">0</span>
                    </div>
                    <div class="panel-body" id="pendingRequestsList">
                        <div class="text-center text-muted">Loading pending requests...</div>
                    </div>
                </div>

                <!-- Current Evaluators Panel -->
                <div class="panel">
                    <div class="panel-header">
                        üë• Current Evaluators
                        <span class="badge" id="currentEvaluatorsBadge">0</span>
                    </div>
                    <div class="panel-body" id="currentEvaluatorsList">
                        <div class="text-center text-muted">Loading current evaluators...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- EVALUATION ALLOCATION TAB -->
        <div id="allocationTab" class="tab-content">
            <!-- Exam Selector -->
            <div class="allocation-panel">
                <div class="panel-header">üéØ Evaluation Allocation Management</div>
                <div class="panel-body">
                    <div class="exam-selector">
                        <label for="examSelect"><strong>Select Exam:</strong></label>
                        <select id="examSelect" onchange="loadExamAllocations()">
                            <option value="">Select an exam...</option>
                        </select>
                        <button class="btn btn-success" onclick="initializeAllocation()">
                            üöÄ Initialize Allocation
                        </button>
                        <button class="btn btn-secondary" onclick="refreshAllocations()">
                            üîÑ Refresh
                        </button>
                    </div>

                    <!-- Allocation Summary -->
                    <div id="allocationSummary" style="display: none;">
                        <h3>üìä Allocation Summary</h3>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number" id="totalEvaluatorsAllocated">0</div>
                                <div>Evaluators Allocated</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="totalAnswerSetsAssigned">0</div>
                                <div>Answer Sets Assigned</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="totalUnassignedPapers">0</div>
                                <div>Unassigned Papers</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number" id="allocationProgress">0%</div>
                                <div>Allocation Progress</div>
                            </div>
                        </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="control-buttons" id="allocationControls" style="display: none;">
                        <button class="btn btn-success" onclick="autoAllocateAnswerSets()">
                            ü§ñ Auto Allocate
                        </button>
                        <button class="btn btn-warning" onclick="clearAllAllocations()">
                            üóëÔ∏è Clear All Allocations
                        </button>
                        <button class="btn btn-secondary" onclick="exportAllocationData()">
                            üìä Export Allocation
                        </button>
                    </div>

                    <!-- Allocation Grid -->
                    <div id="allocationGrid" class="allocation-grid">
                        <div class="text-center text-muted">Select an exam to view allocations</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

        <!-- Add Evaluator Modal -->
        <div id="addEvaluatorModal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>‚ûï Add New Evaluator</h3>
                    <span class="close" onclick="closeAddEvaluatorModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <form id="addEvaluatorForm">
                        <div class="form-group">
                            <label for="evaluatorSelect">Select Tutor:</label>
                            <select id="evaluatorSelect" class="form-control" required>
                                <option value="">Loading tutors...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="evaluatorSubjects">Preferred Subjects:</label>
                            <div id="subjectsContainer" class="checkbox-group">
                                <!-- Subject checkboxes will be populated here -->
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="evaluatorMessage">Admin Note (optional):</label>
                            <textarea id="evaluatorMessage" class="form-control" rows="3" placeholder="Add any notes about this evaluator..."></textarea>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" onclick="closeAddEvaluatorModal()">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="handleAddEvaluator(event)">Add Evaluator</button>
                </div>
            </div>
        </div>

        <!-- Notification -->
        <div id="notification" class="notification" style="display: none;">
            <span id="notificationMessage"></span>
        </div>
    </div>

    <!-- Backend API Scripts -->
    <script src="../../js/supabase-config.js"></script>
    <script src="../../js/backend-init.js"></script>
    <script src="../../js/api/evaluation.js"></script>
    <script src="../../js/api/exam.js"></script>
    <script src="../../js/api/user.js"></script>

    <script>
        // Global variables
        let currentExam = null;
        let allEvaluators = [];
        let allTutors = [];
        let selectedTutorId = null;

        // Page initialization
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Starting evaluation allocation initialization...');

            try {
                // Wait for backend services
                await waitForBackendServices();

                // Load initial data
                await Promise.all([
                    loadEvaluationManagement(),
                    loadExamOptions()
                ]);

                console.log('‚úÖ Page initialized successfully');
            } catch (error) {
                console.error('‚ùå Error during initialization:', error);
                showNotification('Failed to initialize page. Please refresh.', 'error');
            }
        });

        // Wait for backend services
        async function waitForBackendServices() {
            let attempts = 0;
            const maxAttempts = 50;

            while (attempts < maxAttempts) {
                if (window.SUPABASE_CONFIG && 
                    window.evaluationAPI) {
                    console.log('‚úÖ Backend services ready');
                    return;
                }

                attempts++;
                console.log(`‚è≥ Waiting for backend services... (${attempts}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            console.warn('‚ö†Ô∏è Some backend services not available, continuing anyway');
        }

        // Get Supabase client
        function getSupabaseClient() {
            return window.SUPABASE_CONFIG.getClient();
        }

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');

            // Load data for the active tab
            if (tabName === 'allocation') {
                // Only load exam options if backend services are ready
                if (window.SUPABASE_CONFIG) {
                    loadExamOptions();
                } else {
                    console.warn('‚ö†Ô∏è Backend services not ready, skipping exam options load');
                }
            }
        }

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ============================================
        // EVALUATION MANAGEMENT SYSTEM FUNCTIONS
        // ============================================

        // Load evaluation management data
        async function loadEvaluationManagement() {
            try {
                console.log('üìä Loading evaluation management data...');
                await Promise.all([
                    loadPendingRequests(),
                    loadCurrentEvaluators(),
                    loadEvaluationStatistics()
                ]);
                console.log('‚úÖ Evaluation management data loaded');
            } catch (error) {
                console.error('‚ùå Error loading evaluation management:', error);
                showNotification('Failed to load evaluation management data', 'error');
            }
        }

        // Load pending evaluator requests
        async function loadPendingRequests() {
            try {
                const client = getSupabaseClient();
                const { data, error } = await client
                    .from('evaluator_eligibility')
                    .select(`
                        *,
                        user_information!evaluator_eligibility_tutor_id_fkey (
                            full_name,
                            email,
                            profile_picture
                        )
                    `)
                    .eq('enabled', false)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                displayPendingRequests(data || []);
                document.getElementById('totalRequestsCount').textContent = data?.length || 0;
                document.getElementById('pendingRequestsBadge').textContent = data?.length || 0;

            } catch (error) {
                console.error('Error loading pending requests:', error);
                document.getElementById('pendingRequestsList').innerHTML = 
                    '<div class="text-center text-danger">Error loading pending requests</div>';
            }
        }

        // Load current evaluators
        async function loadCurrentEvaluators() {
            try {
                const client = getSupabaseClient();
                const { data: evaluatorsData, error } = await client
                    .from('evaluator_eligibility')
                    .select(`
                        *,
                        user_information!evaluator_eligibility_tutor_id_fkey (
                            full_name,
                            email,
                            profile_picture
                        )
                    `)
                    .eq('enabled', true)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                const enabledEvaluators = evaluatorsData || [];
                allEvaluators = enabledEvaluators; // Update global variable
                displayCurrentEvaluators(enabledEvaluators);

                // Count only enabled evaluators
                const activeCount = enabledEvaluators.length;
                document.getElementById('totalEvaluatorsCount').textContent = activeCount;
                document.getElementById('currentEvaluatorsBadge').textContent = activeCount;

                console.log(`üìä Found ${activeCount} active evaluators`);

            } catch (error) {
                console.error('Error loading current evaluators:', error);
                document.getElementById('currentEvaluatorsList').innerHTML = 
                    '<div class="text-center text-danger">Error loading current evaluators</div>';
            }
        }

        // Load evaluation statistics
        async function loadEvaluationStatistics() {
            try {
                const enabledEvaluators = allEvaluators.filter(e => e.enabled);
                const allSubjects = new Set();

                enabledEvaluators.forEach(evaluator => {
                    if (evaluator.preferred_subjects) {
                        evaluator.preferred_subjects.forEach(subject => allSubjects.add(subject));
                    }
                });

                document.getElementById('totalSubjectsCount').textContent = allSubjects.size;

                const avgSubjects = enabledEvaluators.length > 0 
                    ? (enabledEvaluators.reduce((sum, e) => sum + (e.preferred_subjects?.length || 0), 0) / enabledEvaluators.length).toFixed(1)
                    : 0;
                document.getElementById('averageSubjectsCount').textContent = avgSubjects;

            } catch (error) {
                console.error('Error loading evaluation statistics:', error);
            }
        }

        // Display pending requests
        function displayPendingRequests(requests) {
            const container = document.getElementById('pendingRequestsList');

            if (!requests || requests.length === 0) {
                container.innerHTML = '<div class="text-center text-muted py-4">No pending requests</div>';
                return;
            }

            container.innerHTML = requests.map(request => {
                const profilePicture = request.user_information?.profile_picture 
                    ? `<img src="${request.user_information.profile_picture}" alt="Profile" class="evaluator-avatar">`
                    : '<div class="evaluator-avatar-placeholder">üë§</div>';

                return `
                    <div class="evaluator-card pending-request">
                        <div class="evaluator-header">
                            ${profilePicture}
                            <div class="evaluator-details">
                                <h4>${request.user_information?.full_name || request.tutor_full_name}</h4>
                                <p class="text-muted">${request.user_information?.email || 'No email'}</p>
                                <span class="status-badge pending">‚è≥ Pending</span>
                            </div>
                        </div>
                        <div class="evaluator-body">
                            <p><strong>üìö Subjects:</strong> ${request.preferred_subjects?.join(', ') || 'None specified'}</p>
                            ${request.request_message ? `<p><strong>üí¨ Message:</strong> "${request.request_message}"</p>` : ''}
                            <small class="text-muted">üìÖ Requested: ${new Date(request.created_at).toLocaleDateString()}</small>
                        </div>
                        <div class="evaluator-actions">
                            <button class="btn btn-success btn-sm" onclick="approveRequest('${request.id}')">
                                ‚úÖ Approve
                            </button>
                            <button class="btn btn-danger btn-sm" onclick="rejectRequest('${request.id}')">
                                ‚ùå Reject
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Display current evaluators
        function displayCurrentEvaluators(evaluators) {
            const container = document.getElementById('currentEvaluatorsList');

            if (!evaluators || evaluators.length === 0) {
                container.innerHTML = '<div class="text-center text-muted py-4">No active evaluators</div>';
                return;
            }

            container.innerHTML = evaluators.map(evaluator => {
                const profilePicture = evaluator.user_information?.profile_picture 
                    ? `<img src="${evaluator.user_information.profile_picture}" alt="Profile" class="evaluator-avatar">`
                    : '<div class="evaluator-avatar-placeholder">üë§</div>';

                return `
                    <div class="evaluator-card active-evaluator">
                        <div class="evaluator-header">
                            ${profilePicture}
                            <div class="evaluator-details">
                                <h4>${evaluator.user_information?.full_name || evaluator.tutor_full_name}</h4>
                                <p class="text-muted">${evaluator.user_information?.email || 'No email'}</p>
                                <span class="status-badge active">‚úÖ Active</span>
                            </div>
                        </div>
                        <div class="evaluator-body">
                            <p><strong>üìö Subjects:</strong> ${evaluator.preferred_subjects?.join(', ') || 'None specified'}</p>
                            <small class="text-muted">üìÖ Approved: ${new Date(evaluator.updated_at).toLocaleDateString()}</small>
                        </div>
                        <div class="evaluator-actions">
                            <button class="btn btn-warning btn-sm" onclick="toggleEvaluatorStatus('${evaluator.id}', false)">
                                ‚è∏Ô∏è Disable
                            </button>
                            <button class="btn btn-danger btn-sm" onclick="removeEvaluator('${evaluator.id}')">
                                üóëÔ∏è Remove
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Add evaluator modal functions
        function openAddEvaluatorModal() {
            const modal = document.getElementById('addEvaluatorModal');
            if (modal) {
                modal.style.display = 'block';
                loadTutors();
                loadSubjects();
            } else {
                console.error('Add evaluator modal not found');
            }
        }

        function closeAddEvaluatorModal() {
            const modal = document.getElementById('addEvaluatorModal');
            const form = document.getElementById('addEvaluatorForm');

            if (modal) {
                modal.style.display = 'none';
            }

            if (form) {
                form.reset();
            }

            // Clear subjects
            const subjectsContainer = document.getElementById('subjectsContainer');
            if (subjectsContainer) {
                subjectsContainer.innerHTML = '';
            }
        }

        // Load subjects for selection
        function loadSubjects() {
            const subjectsContainer = document.getElementById('subjectsContainer');
            if (!subjectsContainer) {
                console.error('Subjects container not found');
                return;
            }

            // Common exam subjects
            const subjects = [
                'Mathematics', 'Physics', 'Chemistry', 'Biology', 'English',
                'Bangla', 'ICT', 'Economics', 'Accounting', 'Business Studies',
                'History', 'Geography', 'Civics', 'Psychology', 'Sociology'
            ];

            subjectsContainer.innerHTML = '';

            subjects.forEach(subject => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'subject-checkbox';
                checkboxDiv.innerHTML = `
                    <label>
                        <input type="checkbox" name="subjects" value="${subject}">
                        <span>${subject}</span>
                    </label>
                `;
                subjectsContainer.appendChild(checkboxDiv);
            });
        }

        // Load tutors for dropdown
        async function loadTutors() {
            const tutorSelect = document.getElementById('evaluatorSelect');

            if (!tutorSelect) {
                console.error('Tutor select element not found');
                return;
            }

            try {
                await window.waitForBackend();

                console.log('Loading tutors for evaluator selection...');

                const { data: tutors, error } = await window.supabaseClient
                    .from('user_information')
                    .select('user_id, full_name, email')
                    .eq('role', 'tutor')
                    .order('full_name');

                if (error) {
                    console.error('Error fetching tutors:', error);
                    throw error;
                }

                console.log('Found tutors:', tutors?.length || 0);

                // Clear existing options
                tutorSelect.innerHTML = '<option value="">Select a tutor...</option>';

                if (tutors && tutors.length > 0) {
                    tutors.forEach(tutor => {
                        const option = document.createElement('option');
                        option.value = tutor.user_id;
                        option.textContent = `${tutor.full_name} (${tutor.email})`;
                        tutorSelect.appendChild(option);
                    });
                    console.log('‚úÖ Tutors loaded successfully');
                } else {
                    tutorSelect.innerHTML = '<option value="">No tutors available</option>';
                    console.log('‚ö†Ô∏è No tutors found');
                }

            } catch (error) {
                console.error('Error loading tutors:', error);
                if (tutorSelect) {
                    tutorSelect.innerHTML = '<option value="">Error loading tutors</option>';
                }
            }
        }

        // Handle form submission
        async function handleAddEvaluator(event) {
            event.preventDefault();

            const evaluatorId = document.getElementById('evaluatorSelect').value;
            const subjects = Array.from(document.querySelectorAll('#subjectsContainer input[name="subjects"]:checked')).map(checkbox => checkbox.value);
            const requestMessage = document.getElementById('evaluatorMessage').value;

            console.log('Form data:', { evaluatorId, subjects, requestMessage });

            if (!evaluatorId) {
                showNotification('Please select an evaluator', 'error');
                return;
            }

            if (subjects.length === 0) {
                showNotification('Please select at least one subject', 'error');
                return;
            }

            try {
                const client = getSupabaseClient();

                // First, fetch the tutor's full name
                const { data: tutorData, error: tutorError } = await client
                    .from('user_information')
                    .select('full_name')
                    .eq('user_id', evaluatorId)
                    .single();

                if (tutorError) {
                    console.error('Error fetching tutor data:', tutorError);
                    throw new Error('Failed to fetch tutor information');
                }

                if (!tutorData || !tutorData.full_name) {
                    throw new Error('Tutor full name not found');
                }

                // Check if evaluator already exists
                const { data: existing, error: checkError } = await client
                    .from('evaluator_eligibility')
                    .select('*')
                    .eq('tutor_id', evaluatorId)
                    .single();

                if (checkError && checkError.code !== 'PGRST116') {
                    throw checkError;
                }

                if (existing) {
                    // Update existing record
                    const { error: updateError } = await client
                        .from('evaluator_eligibility')
                        .update({
                            tutor_full_name: tutorData.full_name,
                            preferred_subjects: subjects,
                            request_message: requestMessage,
                            updated_at: new Date().toISOString()
                        })
                        .eq('tutor_id', evaluatorId);

                    if (updateError) throw updateError;
                    showNotification('Evaluator updated successfully!', 'success');
                } else {
                    // Insert new record
                    const { error: insertError } = await client
                        .from('evaluator_eligibility')
                        .insert({
                            tutor_id: evaluatorId,
                            tutor_full_name: tutorData.full_name,
                            preferred_subjects: subjects,
                            request_message: requestMessage,
                            enabled: true // Set enabled to true by default for new evaluators.
                        });

                    if (insertError) throw insertError;
                    showNotification('Evaluator added successfully!', 'success');
                }

                closeAddEvaluatorModal();
                await loadEvaluationManagement(); // Refresh the data

            } catch (error) {
                console.error('Error adding evaluator:', error);
                showNotification('Failed to add evaluator: ' + error.message, 'error');
            }
        }

        // Approve evaluator request
        async function approveRequest(requestId) {
            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .update({ enabled: true })
                    .eq('id', requestId);

                if (error) throw error;

                showNotification('Evaluator request approved successfully', 'success');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error approving request:', error);
                showNotification('Failed to approve request', 'error');
            }
        }

        // Reject evaluator request
        async function rejectRequest(requestId) {
            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .delete()
                    .eq('id', requestId);

                if (error) throw error;

                showNotification('Evaluator request rejected', 'warning');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error rejecting request:', error);
                showNotification('Failed to reject request', 'error');
            }
        }

        // Toggle evaluator status
        async function toggleEvaluatorStatus(evaluatorId, newStatus) {
            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .update({ enabled: newStatus })
                    .eq('id', evaluatorId);

                if (error) throw error;

                showNotification(`Evaluator ${newStatus ? 'enabled' : 'disabled'} successfully`, 'success');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error updating evaluator status:', error);
                showNotification('Failed to update evaluator status', 'error');
            }
        }

        // Remove evaluator
        async function removeEvaluator(evaluatorId) {
            if (!confirm('Are you sure you want to remove this evaluator? This action cannot be undone.')) {
                return;
            }

            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .delete()
                    .eq('id', evaluatorId);

                if (error) throw error;

                showNotification('Evaluator removed successfully', 'success');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error removing evaluator:', error);
                showNotification('Failed to remove evaluator', 'error');
            }
        }

        // Approve all pending requests
        async function approveAllPendingRequests() {
            if (!confirm('Are you sure you want to approve all pending evaluator requests?')) {
                return;
            }

            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .update({ enabled: true })
                    .eq('enabled', false);

                if (error) throw error;

                showNotification('All pending requests approved successfully', 'success');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error approving all requests:', error);
                showNotification('Failed to approve all requests', 'error');
            }
        }

        // Disable all evaluators
        async function disableAllEvaluators() {
            if (!confirm('Are you sure you want to disable all evaluators? This will stop all ongoing evaluations.')) {
                return;
            }

            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_eligibility')
                    .update({ enabled: false })
                    .eq('enabled', true);

                if (error) throw error;

                showNotification('All evaluators disabled successfully', 'warning');
                await loadEvaluationManagement();

            } catch (error) {
                console.error('Error disabling evaluators:', error);
                showNotification('Failed to disable evaluators', 'error');
            }
        }

        // Filter evaluators
        function filterEvaluators() {
            const subjectFilter = document.getElementById('subjectFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            const evaluatorItems = document.querySelectorAll('.evaluator-card');

            evaluatorItems.forEach(item => {
                let show = true;

                if (subjectFilter) {
                    const subjects = Array.from(item.querySelectorAll('.subject-tag')).map(tag => tag.textContent);
                    show = show && subjects.includes(subjectFilter);
                }

                if (statusFilter !== '') {
                    const isEnabled = item.querySelector('.status-badge').classList.contains('active');
                    show = show && (statusFilter === 'true' ? isEnabled : !isEnabled);
                }

                item.style.display = show ? 'block' : 'none';
            });
        }

        // Export evaluation data
        async function exportEvaluationData() {
            try {
                const client = getSupabaseClient();
                const { data, error } = await client
                    .from('evaluator_eligibility')
                    .select(`
                        *,
                        user_information!evaluator_eligibility_tutor_id_fkey (
                            full_name,
                            email
                        )
                    `);

                if (error) throw error;

                const csv = convertToCSV(data);
                downloadCSV(csv, 'evaluator_data.csv');
                showNotification('Evaluation data exported successfully', 'success');

            } catch (error) {
                console.error('Error exporting data:', error);
                showNotification('Failed to export data', 'error');
            }
        }

        // ============================================
        // EVALUATION ALLOCATION SYSTEM FUNCTIONS
        // ============================================

        // Load exam options
        async function loadExamOptions() {
            try {
                console.log('üìä Loading exam options...');
                const client = getSupabaseClient();
                const { data: exams, error } = await client
                    .from('icup_exam_metadata')
                    .select('exam_id, title, exam_type, week_number')
                    .order('week_number', { ascending: false });

                if (error) throw error;

                const examSelect = document.getElementById('examSelect');
                examSelect.innerHTML = '<option value="">Select an exam...</option>';

                if (exams && exams.length > 0) {
                    exams.forEach(exam => {
                        const option = document.createElement('option');
                        option.value = exam.exam_id;
                        option.textContent = exam.title || exam.exam_type || `Week ${exam.week_number}`;
                        examSelect.appendChild(option);
                    });

                    console.log(`‚úÖ Loaded ${exams.length} exam options`);
                } else {
                    console.log('üìä No exams found');
                }
            } catch (error) {
                console.error('‚ùå Error loading exams:', error);
                const examSelect = document.getElementById('examSelect');
                examSelect.innerHTML = '<option value="">Error loading exams</option>';
            }
        }

        // Load exam allocations
        async function loadExamAllocations() {
            const examId = document.getElementById('examSelect').value;
            if (!examId) {
                document.getElementById('allocationSummary').style.display = 'none';
                document.getElementById('allocationControls').style.display = 'none';
                document.getElementById('allocationGrid').innerHTML = 
                    '<div class="text-center text-muted">Select an exam to view allocations</div>';
                return;
            }

            try {
                currentExam = examId;
                console.log('üìä Loading allocations for exam:', examId);

                // Load allocations and answer sets
                await Promise.all([
                    loadAllocationData(examId),
                    loadAnswerSetsData(examId)
                ]);

                // Show allocation interface
                document.getElementById('allocationSummary').style.display = 'block';
                document.getElementById('allocationControls').style.display = 'flex';

                console.log('‚úÖ Exam allocations loaded successfully');
            } catch (error) {
                console.error('‚ùå Error loading exam allocations:', error);
                showNotification('Failed to load exam allocations', 'error');
            }
        }

        // Load allocation data
        async function loadAllocationData(examId) {
            try {
                const client = getSupabaseClient();

                // Get evaluator allocations
                const { data: allocations, error: allocError } = await client
                    .from('evaluator_allocation')
                    .select(`
                        *,
                        user_information!evaluator_allocation_evaluator_id_fkey (
                            full_name,
                            profile_picture
                        )
                    `)
                    .eq('exam_id', examId);

                if (allocError) throw allocError;

                // Get available evaluators
                const { data: evaluators, error: evalError } = await client
                    .from('evaluator_eligibility')
                    .select(`
                        *,
                        user_information!evaluator_eligibility_tutor_id_fkey (
                            full_name,
                            profile_picture
                        )
                    `)
                    .eq('enabled', true);

                if (evalError) throw evalError;

                displayAllocationData(allocations || [], evaluators || []);
                updateAllocationSummary(allocations || []);

            } catch (error) {
                console.error('Error loading allocation data:', error);
                document.getElementById('allocationGrid').innerHTML = 
                    '<div class="text-center text-danger">Error loading allocation data</div>';
            }
        }

        // Load answer sets data
        async function loadAnswerSetsData(examId) {
            try {
                const client = getSupabaseClient();
                const { data: answerSets, error } = await client
                    .from('answer_sets')
                    .select('answer_set_id, student_id')
                    .eq('exam_id', examId);

                if (error) throw error;

                // Since subject column doesn't exist, we'll create mock data for all subjects
                const subjects = ['Mathematics', 'Physics', 'Chemistry', 'Biology', 'English', 'Bangla', 'General Knowledge'];
                const mockAnswerSets = [];
                
                subjects.forEach(subject => {
                    if (answerSets) {
                        answerSets.forEach(as => {
                            mockAnswerSets.push({
                                ...as,
                                subject: subject
                            });
                        });
                    }
                });

                // Store for allocation purposes
                window.currentExamAnswerSets = mockAnswerSets;
                console.log(`üìä Loaded ${mockAnswerSets.length} answer sets for exam (mock data)`);

            } catch (error) {
                console.error('Error loading answer sets:', error);
                window.currentExamAnswerSets = [];
            }
        }

        // Display allocation data
        function displayAllocationData(allocations, evaluators) {
            const subjects = ['Mathematics', 'Physics', 'Chemistry', 'Biology', 'English', 'Bangla', 'General Knowledge'];

            const html = subjects.map(subject => {
                const subjectAllocations = allocations.filter(a => a.subject === subject);
                const eligibleEvaluators = evaluators.filter(e => 
                    e.preferred_subjects && e.preferred_subjects.includes(subject)
                );
                const unassignedAnswerSets = window.currentExamAnswerSets?.filter(as => 
                    as.subject === subject && !allocations.some(alloc => 
                        alloc.assigned_answer_sets && alloc.assigned_answer_sets.includes(as.answer_set_id)
                    )
                ) || [];

                return `
                    <div class="subject-allocation">
                        <div class="subject-header">
                            <span>üìö ${subject}</span>
                            <span>${subjectAllocations.length} Evaluators | ${unassignedAnswerSets.length} Unassigned</span>
                        </div>
                        <div class="allocation-content">
                            ${subjectAllocations.length > 0 ? 
                                subjectAllocations.map(allocation => {
                                    const assignedCount = allocation.assigned_answer_sets?.length || 0;
                                    return `
                                        <div class="evaluator-allocation">
                                            <div class="allocation-info">
                                                ${allocation.user_information?.profile_picture ? 
                                                    `<img src="${allocation.user_information.profile_picture}" alt="Profile" class="profile-pic">` :
                                                    `<div class="profile-pic-placeholder">${(allocation.user_information?.full_name || 'U').charAt(0).toUpperCase()}</div>`
                                                }
                                                <div>
                                                    <strong>${allocation.user_information?.full_name || 'Unknown Evaluator'}</strong>
                                                    <span class="answer-sets-count">${assignedCount} Papers</span>
                                                    <div class="small text-muted">${allocation.status || 'Active'}</div>
                                                </div>
                                            </div>
                                            <div class="allocation-actions">
                                                <button class="btn btn-warning btn-sm" onclick="reassignPapers('${allocation.id}', '${subject}')">
                                                    üîÑ Reassign
                                                </button>
                                                <button class="btn btn-danger btn-sm" onclick="removeAllocation('${allocation.id}')">
                                                    üóëÔ∏è Remove
                                                </button>
                                            </div>
                                        </div>
                                    `;
                                }).join('') : 
                                '<div class="text-muted">No evaluators assigned</div>'
                            }

                            ${unassignedAnswerSets.length > 0 ? `
                                <div class="unassigned-papers">
                                    <strong>üìÑ Unassigned Papers: ${unassignedAnswerSets.length}</strong>
                                    <div class="paper-assignment">
                                        <select id="evaluator-${subject}" style="flex-grow: 1;">
                                            <option value="">Select evaluator...</option>
                                            ${eligibleEvaluators.map(eval => 
                                                `<option value="${eval.tutor_id}">${eval.user_information?.full_name || eval.tutor_full_name}</option>`
                                            ).join('')}
                                        </select>
                                        <button class="btn btn-success btn-sm" onclick="assignPapers('${subject}')">
                                            ‚ûï Assign
                                        </button>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('allocationGrid').innerHTML = html;
        }

        // Update allocation summary
        function updateAllocationSummary(allocations) {
            const totalEvaluators = new Set(allocations.map(a => a.evaluator_id)).size;
            const totalAssigned = allocations.reduce((sum, a) => sum + (a.assigned_answer_sets?.length || 0), 0);
            const totalAnswerSets = window.currentExamAnswerSets?.length || 0;
            const unassigned = totalAnswerSets - totalAssigned;
            const progress = totalAnswerSets > 0 ? Math.round((totalAssigned / totalAnswerSets) * 100) : 0;

            document.getElementById('totalEvaluatorsAllocated').textContent = totalEvaluators;
            document.getElementById('totalAnswerSetsAssigned').textContent = totalAssigned;
            document.getElementById('totalUnassignedPapers').textContent = unassigned;
            document.getElementById('allocationProgress').textContent = `${progress}%`;
        }

        // Initialize allocation
        async function initializeAllocation() {
            if (!currentExam) {
                showNotification('Please select an exam first', 'warning');
                return;
            }

            try {
                showNotification('Initializing allocation...', 'success');
                await loadExamAllocations();

            } catch (error) {
                console.error('Error initializing allocation:', error);
                showNotification('Failed to initialize allocation', 'error');
            }
        }

        // Auto allocate answer sets
        async function autoAllocateAnswerSets() {
            if (!currentExam) {
                showNotification('Please select an exam first', 'warning');
                return;
            }

            if (!confirm('Are you sure you want to auto-allocate all unassigned answer sets?')) {
                return;
            }

            try {
                showNotification('Auto-allocating answer sets...', 'success');

                const client = getSupabaseClient();
                const subjects = ['Mathematics', 'Physics', 'Chemistry', 'Biology', 'English', 'Bangla', 'General Knowledge'];

                for (const subject of subjects) {
                    // Get eligible evaluators for this subject
                    const { data: evaluators, error: evalError } = await client
                        .from('evaluator_eligibility')
                        .select('tutor_id')
                        .eq('enabled', true)
                        .contains('preferred_subjects', [subject]);

                    if (evalError) continue;

                    // Get unassigned answer sets for this subject
                    const unassignedAnswerSets = window.currentExamAnswerSets?.filter(as => 
                        as.subject === subject
                    ) || [];

                    if (evaluators.length > 0 && unassignedAnswerSets.length > 0) {
                        // Distribute answer sets among evaluators
                        const answersPerEvaluator = Math.ceil(unassignedAnswerSets.length / evaluators.length);

                        for (let i = 0; i < evaluators.length; i++) {
                            const startIndex = i * answersPerEvaluator;
                            const endIndex = Math.min(startIndex + answersPerEvaluator, unassignedAnswerSets.length);
                            const assignedAnswerSets = unassignedAnswerSets.slice(startIndex, endIndex).map(as => as.answer_set_id);

                            if (assignedAnswerSets.length > 0) {
                                await client
                                    .from('evaluator_allocation')
                                    .upsert({
                                        exam_id: currentExam,
                                        subject: subject,
                                        evaluator_id: evaluators[i].tutor_id,
                                        assigned_answer_sets: assignedAnswerSets,
                                        status: 'pending'
                                    });
                            }
                        }
                    }
                }

                showNotification('Auto-allocation completed successfully', 'success');
                await loadExamAllocations();

            } catch (error) {
                console.error('Error auto-allocating:', error);
                showNotification('Failed to auto-allocate answer sets', 'error');
            }
        }

        // Clear all allocations
        async function clearAllAllocations() {
            if (!currentExam) {
                showNotification('Please select an exam first', 'warning');
                return;
            }

            if (!confirm('Are you sure you want to clear all allocations for this exam?')) {
                return;
            }

            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_allocation')
                    .delete()
                    .eq('exam_id', currentExam);

                if (error) throw error;

                showNotification('All allocations cleared successfully', 'success');
                await loadExamAllocations();

            } catch (error) {
                console.error('Error clearing allocations:', error);
                showNotification('Failed to clear allocations', 'error');
            }
        }

        // Assign papers to evaluator
        async function assignPapers(subject) {
            const evaluatorSelect = document.getElementById(`evaluator-${subject}`);
            const evaluatorId = evaluatorSelect.value;

            if (!evaluatorId) {
                showNotification('Please select an evaluator', 'warning');
                return;
            }

            try {
                // Get unassigned answer sets for this subject
                const unassignedAnswerSets = window.currentExamAnswerSets?.filter(as => 
                    as.subject === subject
                ) || [];

                const answerSetIds = unassignedAnswerSets.map(as => as.answer_set_id);

                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_allocation')
                    .upsert({
                        exam_id: currentExam,
                        subject: subject,
                        evaluator_id: evaluatorId,
                        assigned_answer_sets: answerSetIds,
                        status: 'pending'
                    });

                if (error) throw error;

                showNotification(`Papers assigned to evaluator for ${subject}`, 'success');
                await loadExamAllocations();

            } catch (error) {
                console.error('Error assigning papers:', error);
                showNotification('Failed to assign papers', 'error');
            }
        }

        // Remove allocation
        async function removeAllocation(allocationId) {
            if (!confirm('Are you sure you want to remove this allocation?')) {
                return;
            }

            try {
                const client = getSupabaseClient();
                const { error } = await client
                    .from('evaluator_allocation')
                    .delete()
                    .eq('id', allocationId);

                if (error) throw error;

                showNotification('Allocation removed successfully', 'success');
                await loadExamAllocations();

            } catch (error) {
                console.error('Error removing allocation:', error);
                showNotification('Failed to remove allocation', 'error');
            }
        }

        // Reassign papers
        async function reassignPapers(allocationId, subject) {
            // Implementation for reassigning papers
            showNotification('Reassignment feature coming soon', 'warning');
        }

        // Refresh allocations
        function refreshAllocations() {
            if (currentExam) {
                loadExamAllocations();
            } else {
                showNotification('Please select an exam first', 'warning');
            }
        }

        // Export allocation data
        async function exportAllocationData() {
            if (!currentExam) {
                showNotification('Please select an exam first', 'warning');
                return;
            }

            try {
                const client = getSupabaseClient();
                const { data, error } = await client
                    .from('evaluator_allocation')
                    .select('*')
                    .eq('exam_id', currentExam);

                if (error) throw error;

                const csv = convertToCSV(data);
                downloadCSV(csv, `allocation_data_${currentExam}.csv`);
                showNotification('Allocation data exported successfully', 'success');

            } catch (error) {
                console.error('Error exporting allocation data:', error);
                showNotification('Failed to export allocation data', 'error');
            }
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        // Convert data to CSV
        function convertToCSV(data) {
            if (!data || data.length === 0) return '';

            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => 
                    headers.map(header => {
                        const cell = row[header];
                        if (Array.isArray(cell)) {
                            return `"${cell.join(';')}"`;
                        }
                        return `"${cell || ''}"`;
                    }).join(',')
                )
            ].join('\n');

            return csvContent;
        }

        // Download CSV file
        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Make functions globally accessible
        window.openAddEvaluatorModal = openAddEvaluatorModal;
        window.closeAddEvaluatorModal = closeAddEvaluatorModal;
        window.handleAddEvaluator = handleAddEvaluator;
    </script>
</body>
</html>